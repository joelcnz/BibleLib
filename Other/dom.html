<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>arsd.dom</title>
        </head><body>
        <h1>arsd.dom</h1>
        <!-- Generated by Ddoc from dom.d -->
<br><br>
<dl><dt><big>T[] <u>insertAfter</u>(T)(T[] <i>arr</i>, int <i>position</i>, T[] <i>what</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>isInArray</u>(T)(T <i>item</i>, T[] <i>arr</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>class <u>Stack</u>(T);
</big></dt>
<dd>.<br><br>

<dl><dt><big>void <u>push</u>(T <i>t</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>T <u>pop</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>T <u>peek</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>empty</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>T[] <u>arr</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>ElementStream</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>Element <u>front</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>this(Element <i>start</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>popFront</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>currentKilled</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>empty</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>struct <u>Current</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Current <u>current</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Stack!(Current) <u>stack</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>isEmpty</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>string[string] <u>dup</u>(in string[string] <i>arr</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>class <u>Element</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>Element[] <u>children</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>tagName</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string[string] <u>attributes</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>pure Document <u>parentDocument</u>();
</big></dt>
<dd>Get the parent Document object that contains this element.
 It may return <b>null</b> and/or run in O(n) time with the height of the tree.<br><br>

</dd>
<dt><big>this(Document <i>_parentDocument</i>, string <i>_tagName</i>, string[string] <i>_attributes</i> = null, bool <i>_selfClosed</i> = false);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element <u>previousSibling</u>(string <i>tagName</i> = null);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element <u>nextSibling</u>(string <i>tagName</i> = null);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property CssStyle <u>computedStyle</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element <u>cloned</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element <u>firstChild</u>();
</big></dt>
<dd>Returns the first child of this element. If it has no children, returns <b>null</b>.<br><br>

</dd>
<dt><big>this(string <i>_tagName</i>, string[string] <i>_attributes</i> = null);
</big></dt>
<dd>Convenience constructor when you don't care about the parentDocument. Note this might break things on the document.
 Note also that without a parent document, elements are always in strict, case-sensitive mode.<br><br>

</dd>
<dt><big>Element <u>appendChild</u>(Element <i>e</i>);
</big></dt>
<dd>Appends the given element to this one. The given element must not have a parent already.<br><br>

</dd>
<dt><big>Element <u>insertBefore</u>(Element <i>where</i>, Element <i>what</i>);
</big></dt>
<dd>Inserts the second element to this node, right before the first param<br><br>

</dd>
<dt><big>Element <u>insertAfter</u>(Element <i>where</i>, Element <i>what</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>static Element <u>make</u>(string <i>tagName</i>, string <i>childInfo</i> = null, string <i>childInfo2</i> = null);
</big></dt>
<dd>Convenience function to try to do the right thing for HTML<br><br>

</dd>
<dt><big>Element <u>addChild</u>(string <i>tagName</i>, string <i>childInfo</i> = null, string <i>childInfo2</i> = null);
</big></dt>
<dd>convenience function to quickly add a tag with some text or
 other relevant info (for example, it's a src for an <img> element
 instead of inner text)<br><br>

</dd>
<dt><big>Element <u>addChild</u>(string <i>tagName</i>, Element <i>firstChild</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>T <u>getParent</u>(T)(string <i>tagName</i> = null);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>swapNode</u>(Element <i>child</i>, Element <i>replacement</i>);
</big></dt>
<dd>swaps one <i>child</i> for a new thing. Returns the old <i>child</i> which is now parentless.<br><br>

</dd>
<dt><big>Element <u>getElementById</u>(string <i>id</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>SomeElementType <u>requireElementById</u>(SomeElementType = Element)(string <i>id</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>SomeElementType <u>requireSelector</u>(SomeElementType = Element)(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>querySelector</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>querySelectorAll</u>(string <i>selector</i>);
</big></dt>
<dd>a more standards-compliant alias for getElementsBySelector<br><br>

</dd>
<dt><big>Element[] <u>getElementsBySelector</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>getElementsByTagName</u>(string <i>tag</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>appendText</u>(string <i>text</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element[] <u>childElements</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>appendHtml</u>(string <i>html</i>);
</big></dt>
<dd>Appends the given <i>html</i> to the element, returning the elements appended<br><br>

</dd>
<dt><big>Element <u>addClass</u>(string <i>c</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>removeClass</u>(string <i>c</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>hasClass</u>(string <i>c</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>reparent</u>(Element <i>newParent</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>insertChildAfter</u>(Element <i>child</i>, Element <i>where</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>stealChildren</u>(Element <i>e</i>, Element <i>position</i> = null);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>prependChild</u>(Element <i>e</i>);
</big></dt>
<dd>Puts the current element first in our children list. The given element must not have a parent already.<br><br>

</dd>
<dt><big>string <u>opDispatch</u>(string name)(string <i>v</i> = null);
</big></dt>
<dd>Provides easy access to attributes, like in javascript<br><br>

</dd>
<dt><big>const @property const(Element[]) <u>childNodes</u>();
</big></dt>
<dd>Returns the element's children.<br><br>

</dd>
<dt><big>@property Element[] <u>childNodes</u>();
</big></dt>
<dd>Mutable version of the same<br><br>

</dd>
<dt><big>const @property int <u>nodeType</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const @property string <u>innerHTML</u>();
</big></dt>
<dd>Returns a string containing all child elements, formatted such that it could be pasted into
		an XML file.<br><br>

</dd>
<dt><big>@property void <u>innerHTML</u>(string <i>html</i>);
<br>@property void <u>innerHTML</u>(Html <i>html</i>);
</big></dt>
<dd>Takes some <i>html</i> and replaces the element's children with the tree made from the string.<br><br>

</dd>
<dt><big>@property Element[] <u>outerHTML</u>(string <i>html</i>);
</big></dt>
<dd>Replaces this node with the given <i>html</i> string, which is parsed
<br><br>
<b>Note:</b><br>
this invalidates the this reference, since it is removed
		from the tree.
<br><br>

		Returns the new children that replace this.<br><br>

</dd>
<dt><big>@property string <u>outerHTML</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property void <u>innerRawSource</u>(string <i>rawSource</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>getAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Gets the given attribute value, or <b>null</b> if the
		attribute is not set.
<br><br>
Note that the returned string is decoded, so it no longer contains any xml entities.<br><br>

</dd>
<dt><big>Element <u>setAttribute</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>Sets an attribute. Returns this for easy chaining<br><br>

</dd>
<dt><big>bool <u>hasAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Extension<br><br>

</dd>
<dt><big>void <u>removeAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Extension<br><br>

</dd>
<dt><big>const string <u>className</u>();
</big></dt>
<dd>Gets the class attribute's contents. Returns
		an empty string if it has no class.<br><br>

</dd>
<dt><big>Element <u>className</u>(string <i>c</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>nodeValue</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>replaceChild</u>(Element <i>find</i>, Element <i>replace</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>removeChild</u>(Element <i>c</i>);
</big></dt>
<dd>Removes the given child from this list.
<br><br>
Returns the removed element.<br><br>

</dd>
<dt><big>Element[] <u>removeChildren</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>replaceChild</u>(Element <i>find</i>, Element[] <i>replace</i>);
</big></dt>
<dd>EXTENSION
<br><br>
Replaces the given element with a whole group.<br><br>

</dd>
<dt><big>Element <u>parentNode</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>stripOut</u>();
</big></dt>
<dd>Strips this tag out of the document, putting its inner html
		as children of the parent.<br><br>

</dd>
<dt><big>Element <u>removeFromTree</u>();
</big></dt>
<dd>shorthand for this.parentNode.removeChild(this) with parentNode <b>null</b> check<br><br>

</dd>
<dt><big>Element <u>wrapIn</u>(Element <i>what</i>);
</big></dt>
<dd>Wraps this element inside the given element.
 It's like this.replaceWith(<i>what</i>); <i>what</i>.appendchild(this);<br><br>

</dd>
<dt><big>const string[] <u>classNames</u>();
</big></dt>
<dd>INCOMPATIBLE -- extension
<br><br>
Splits the className into an array of each class given<br><br>

</dd>
<dt><big>const string <u>firstInnerText</u>();
</big></dt>
<dd>Fetches the first consecutive text nodes, concatenated together<br><br>

</dd>
<dt><big>const @property string <u>innerText</u>();
</big></dt>
<dd>Fetch the inside text, with all tags stripped out<br><br>

</dd>
<dt><big>@property void <u>innerText</u>(string <i>text</i>);
</big></dt>
<dd>Sets the inside <i>text</i>, replacing all children<br><br>

</dd>
<dt><big>@property void <u>outerText</u>(string <i>text</i>);
</big></dt>
<dd>Strips this node out of the document, replacing it with the given <i>text</i><br><br>

</dd>
<dt><big>const @property string <u>outerText</u>();
</big></dt>
<dd>Same result as innerText; the tag with all tags stripped out<br><br>

</dd>
<dt><big>const string <u>toString</u>();
</big></dt>
<dd>Turns the whole element, including tag, attributes, and children, into a string which could be pasted into
		an XML file.<br><br>

</dd>
<dt><big>ElementStream <u>tree</u>();
</big></dt>
<dd>Returns a lazy range of all its children, recursively.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>DocumentFragment</u>: arsd.dom.Element;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>string <u>htmlEntitiesEncode</u>(string <i>data</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>xmlEntitiesEncode</u>(string <i>data</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>dchar <u>parseEntity</u>(in dchar[] <i>entity</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>htmlEntitiesDecode</u>(string <i>data</i>, bool <i>strict</i> = false);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>class <u>RawSource</u>: arsd.dom.Element;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>, string <i>s</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>nodeValue</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const int <u>nodeType</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>appendChild</u>(Element <i>e</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>source</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>NodeType</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>class <u>TextNode</u>: arsd.dom.Element;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>, string <i>e</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>static TextNode <u>fromUndecodedString</u>(Document <i>_parentDocument</i>, string <i>html</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property Element <u>cloned</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>nodeValue</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const int <u>nodeType</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>appendChild</u>(Element <i>e</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>contents</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Link</u>: arsd.dom.Element;
</big></dt>
<dd>There are subclasses of Element offering improved helper
	functions for the element in HTML.
.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>this(string <i>href</i>, string <i>text</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>getValue</u>(string <i>name</i>);
</big></dt>
<dd>This gets a variable from the URL's query string.<br><br>

</dd>
<dt><big>void <u>updateQueryString</u>(string[string] <i>vars</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>setValue</u>(string <i>name</i>, string <i>variable</i>);
</big></dt>
<dd>Sets or adds the <i>variable</i> with the given <i>name</i> to the given value
 It automatically URI encodes the values and takes care of the ? and &amp;.<br><br>

</dd>
<dt><big>void <u>removeValue</u>(string <i>name</i>);
</big></dt>
<dd>Removes the given variable from the query string<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Form</u>: arsd.dom.Element;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>setValue</u>(string <i>field</i>, string <i>value</i>, bool <i>makeNew</i> = true);
</big></dt>
<dd>Set's the form <i>field</i>'s <i>value</i>. For input boxes, this sets the <i>value</i> attribute. For
 textareas, it sets the innerText. For radio boxes and select boxes, it removes
 the checked/selected attribute from all, and adds it to the one matching the <i>value</i>.
 For checkboxes, if the <i>value</i> is non-<b>null</b> and not empty, it checks the box.
 If you set a <i>value</i> that doesn't exist, it throws an exception if <i>makeNew</i> is <b>false</b>.
 Otherwise, it makes a new input with type=hidden to keep the <i>value</i>.<br><br>

</dd>
<dt><big>string <u>getValue</u>(string <i>field</i>);
</big></dt>
<dd>Gets the value of the <i>field</i>; what would be given if it submitted right now. (so
 it handles select boxes and radio buttons too). For checkboxes, if a value isn't
 given, but it is checked, it returns "checked", since <b>null</b> and "" are indistinguishable<br><br>

</dd>
<dt><big>string <u>getPostableData</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>getField</u>(string <i>name</i>);
</big></dt>
<dd>Gets the actual elements with the given <i>name</i><br><br>

</dd>
<dt><big>Element <u>getLabel</u>(string <i>forId</i>);
</big></dt>
<dd>Grabs the <label> with the given for tag, if there is one.<br><br>

</dd>
<dt><big>Element <u>addField</u>(string <i>name</i>, string <i>value</i>, string <i>type</i> = "hidden");
</big></dt>
<dd>Adds a new INPUT field to the end of the form with the given attributes.<br><br>

</dd>
<dt><big>void <u>removeField</u>(string <i>name</i>);
</big></dt>
<dd>Removes the given field from the form. It finds the element and knocks it right out.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Table</u>: arsd.dom.Element;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(Document <i>_parentDocument</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>th</u>(T)(T <i>t</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>td</u>(T)(T <i>t</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>appendRow</u>(T...)(T <i>t</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>captionElement</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property string <u>caption</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property void <u>caption</u>(string <i>text</i>);
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>MarkupError</u>: object.Exception;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(string <i>message</i>);
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>ElementNotFoundException</u>: object.Exception;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(string <i>type</i>, string <i>search</i>);
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Html</u>;
</big></dt>
<dd>The html struct is used to differentiate between regular text nodes and html in certain functions<br><br>

<dl><dt><big>string <u>source</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Document</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(string <i>data</i>, bool <i>caseSensitive</i> = false, bool <i>strict</i> = false);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>this();
</big></dt>
<dd>Creates an empty document. It has *nothing* in it at all.<br><br>

</dd>
<dt><big>void <u>parse</u>(string <i>data</i>, bool <i>caseSensitive</i> = false, bool <i>strict</i> = false);
</big></dt>
<dd>Concatenates any consecutive text nodes
<br><br>
Take XMLish* <i>data</i> and try to make the DOM tree out of it.
<br><br>

		The goal isn't to be perfect, but to just be good enough to
		approximate Javascript's behavior.
<br><br>

		If <i>strict</i>, it throws on something that doesn't make sense.
		(Examples: mismatched tags. It doesn't validate!)
		If not <i>strict</i>, it tries to recover anyway, and only throws
		when something is REALLY unworkable.
<br><br>

		If <i>strict</i> is <b>false</b>, it uses a magic list of tags that needn't
		be closed. If you are writing a document specifically for this,
		try to avoid such - use self closed tags at least. Easier to <u>parse</u>.
<br><br>

 The xml version at the top really shouldn't be there...<br><br>

</dd>
<dt><big>@property string <u>title</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>@property void <u>title</u>(string <i>t</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>getElementById</u>(string <i>id</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>SomeElementType <u>requireElementById</u>(SomeElementType = Element)(string <i>id</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>SomeElementType <u>requireSelector</u>(SomeElementType = Element)(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>querySelector</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>querySelectorAll</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>getElementsBySelector</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>getElementsByTagName</u>(string <i>tag</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>getFirstElementByTagName</u>(string <i>tag</i>);
</big></dt>
<dd><b>Extension:</b><br>
<br><br>
<b>FIXME:</b><br>
btw, this could just be a lazy range...... <br><br>

</dd>
<dt><big>Element <u>mainBody</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>getMeta</u>(string <i>name</i>);
</big></dt>
<dd>this uses a weird thing... it's [<i>name</i>=] if no colon and
 [property=] if colon<br><br>

</dd>
<dt><big>void <u>setMeta</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Form[] <u>forms</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Form <u>createForm</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>createElement</u>(string <i>name</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>createFragment</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>createTextNode</u>(string <i>content</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>findFirst</u>(bool delegate(Element) <i>doesItMatch</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>clear</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>setProlog</u>(string <i>d</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>prolog</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>const string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element <u>root</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>loose</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>int <u>intFromHex</u>(string <i>hex</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>static immutable string[] <u>selectorTokens</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>int <u>idToken</u>(string <i>str</i>, int <i>position</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string[] <u>lexSelector</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>struct <u>SelectorPart</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>string <u>tagNameFilter</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string[] <u>attributesPresent</u>;
</big></dt>
<dd>[attr]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesEqual</u>;
</big></dt>
<dd>[attr=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesStartsWith</u>;
</big></dt>
<dd>[attr^=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesEndsWith</u>;
</big></dt>
<dd>[attr$=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesIncludesSeparatedBySpaces</u>;
</big></dt>
<dd>[attr~=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesIncludesSeparatedByDashes</u>;
</big></dt>
<dd>[attr|=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesInclude</u>;
</big></dt>
<dd>[attr*=value]<br><br>

</dd>
<dt><big>string[2u][] <u>attributesNotEqual</u>;
</big></dt>
<dd>[attr!=value] -- extension by me<br><br>

</dd>
<dt><big>bool <u>firstChild</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>lastChild</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>emptyElement</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>oddChild</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>evenChild</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>rootElement</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>int <u>separation</u>;
</big></dt>
<dd>-1 == only itself; the <b>null</b> selector, 0 == tree, 1 == childNodes, 2 == childAfter, 3 == youngerSibling, 4 == parentOf<br><br>

</dd>
<dt><big>string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>matchElement</u>(Element <i>e</i>);
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>Element[] <u>getElementsBySelectorParts</u>(Element <i>start</i>, SelectorPart[] <i>parts</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>struct <u>Selector</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>SelectorPart[] <u>parts</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>getElements</u>(Element <i>start</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>bool <u>matchElement</u>(Element <i>e</i>, Element <i>relativeTo</i> = null);
</big></dt>
<dd>If <i>relativeTo</i> == <b>null</b>, it assumes the root of the parent document.<br><br>

</dd>
<dt><big>static Selector <u>fromString</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>Selector[] <u>parseSelectorString</u>(string <i>selector</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Selector <u>parseSelector</u>(string[] <i>tokens</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Element[] <u>removeDuplicates</u>(Element[] <i>input</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>unCamelCase</u>(string <i>a</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>camelCase</u>(string <i>a</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>class <u>CssStyle</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>this(string <i>rule</i>, string <i>content</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Specificity <u>getSpecificityOfRule</u>(string <i>rule</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>originatingRule</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Specificity <u>originatingSpecificity</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>union <u>Specificity</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>uint <u>score</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>ubyte <u>tags</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>ubyte <u>classes</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>ubyte <u>ids</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>ubyte <u>important</u>;
</big></dt>
<dd>0 = none, 1 = stylesheet author, 2 = inline style, 3 = user <u>important</u>
.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Property</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>bool <u>givenExplicitly</u>;
</big></dt>
<dd>this is <b>false</b> if for example the user said "padding" and this is "padding-left"<br><br>

</dd>
<dt><big>string <u>name</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>value</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>Specificity <u>specificity</u>;
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>Property[] <u>properties</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>opDispatch</u>(string nameGiven)(string <i>value</i> = null);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>getValue</u>(string <i>name</i>);
</big></dt>
<dd>takes dash style <i>name</i><br><br>

</dd>
<dt><big>string <u>setValue</u>(string <i>name</i>, string <i>value</i>, Specificity <i>newSpecificity</i>, bool <i>explicit</i> = true);
</big></dt>
<dd>takes dash style <i>name</i><br><br>

</dd>
<dt><big>void <u>expandShortForm</u>(Property <i>p</i>, Specificity <i>specificity</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>string <u>toString</u>();
</big></dt>
<dd>.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>StyleSheet</u>;
</big></dt>
<dd>.<br><br>

<dl><dt><big>CssStyle[] <u>rules</u>;
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>this(string <i>source</i>);
</big></dt>
<dd>.<br><br>

</dd>
<dt><big>void <u>apply</u>(Document <i>document</i>);
</big></dt>
<dd>Run through the <i>document</i> and <u>apply</u> this stylesheet to it. The computedStyle member will be accurate after this call<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
